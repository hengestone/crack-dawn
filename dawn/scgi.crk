## SCGI handler, derived from httpsrv.crk
##
## Copyright 2012 Google Inc.
## Copyright 2012 Shannon Weyrick <weyrick@mozek.us>
## Copyright 2012 Conrad Steenberg <conrad.steenberg@gmail.com>
## 
##   This Source Code Form is subject to the terms of the Mozilla Public
##   License, v. 2.0. If a copy of the MPL was not distributed with this
##   file, You can obtain one at http://mozilla.org/MPL/2.0/.
## 

import crack.ascii strip;
import crack.lang AppendBuffer, Buffer, ManagedBuffer, WriteBuffer, Formatter;
import crack.strutil StringArray;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.io cerr, StandardFormatter, StringFormatter, Writer, FileHandle;
import crack.net InetAddress, Poller, Socket, AF_INET, POLLIN,
    POLLOUT, POLLERR, SOCK_STREAM;
import crack.time TimeDelta;
import crack.sys strerror;
import crack.lang SystemError;
import crack.runtime errno;
import crack.functor Functor1;
import crack.logger debug, info;

@import crack.ann define, interface, implements;

StandardFormatter NULL_FORMATTER = null;

## Contains the full contents of an HTTP request and provides the means for 
## communicating back to the client.
class SCGIRequest {
    String method, path, version;
    HashMap[String, String] headers = {};
    InetAddress clientAddr;
    StandardFormatter __clt;

    oper init(Writer client, ## the channel to write back to the client.
              InetAddress clientAddr ## the client address.
              ) :
        method = method,
        path = path,
        version = version,
        clientAddr = clientAddr,
        __clt(client) {
    }
    
    ## Sends a reply to the client with the specified code, content type and 
    ## contents.
    void sendReply(int code, String contentType, String contents) {
        __clt `HTTP/1.1 $code Stat
Content-type: $contentType
Content-length: $(contents.size)

$contents`;
    }
    
    void sendRedirect(int code, String location) {
        __clt `HTTP/1.1 $code Stat
Location: $location

`;
    }
}

uintz normalizeIndex(intz index, uintz size) {
    if (index < 0)
        index = size + index;
    
    # if it's still zero, trim to zero
    if (index < 0)
        index = 0;
    
    # if greater than the limit, trim to the limit.
    else if (index > size)
        index = size;
    
    return index;
}

## Joins an array of path components into a path.
String joinPath(StringArray path, int start, int end) {
    size := path.count();
    s := normalizeIndex(start, size);
    e := normalizeIndex(end, size);

    # figure out how much space we need for all strings separated by slashes.
    uintz bufSize;
    for (elem :in path)
        bufSize += elem.size;
    bufSize += size - 1;

    AppendBuffer buf = {bufSize};
    for (int i = start; i < end; ++i) {
        if (i == start)
            buf.append(b'/');
        buf.extend(path[i]);
    }
    
    return String(buf, true);
}
        

const int _ST_REQUEST = 0;
const int _ST_HEADERS= 1;
const int _ST_BODY = 2;

## Error formatter.  Writes a message to cerr (TODO: to a logger) and sends an 
## error reply with the message as its parcel.
class Error : StringFormatter {
    SCGIRequest req;
    int code;
    oper init(SCGIRequest req, int code) : req = req, code = code {}

    void leave() {
        result := createString();
        cerr.write(result);
        req.sendReply(code, "text/plain", result);
    }
}

## Request handler interface.  This interface dispatches a handler to 
## interface methods corresponding to the HTTP GET, PUT and POST methods.
@interface SCGIRequestHandler {
    bool onGet(SCGIRequest req) {
        Error(req, 405) `GET Method not allowed for $(req.path)`;
        return true;
    }

    bool onPut(SCGIRequest req) {
        Error(req, 405) `PUT Method not allowed for $(req.path)`;
        return true;
    }
    
    bool onPost(SCGIRequest req) {
        Error(req, 405) `PUT Method not allowed for $(req.path)`;
        return true;
    }

    bool oper call(SCGIRequest req) {
        if (req.method == 'GET')
            return onGet(req);
        else if (req.method == 'POST')
            return onPost(req);
        else if (req.method == 'PUT')
            return onPut(req);
        else {
            Error(req, 405) `Invalid method $(req.method)`;
            return false;
        }
    }
        
}

alias RequestHandler = Functor1[bool, SCGIRequest];
alias HandlerArray = Array[RequestHandler];

class OutQueue : Array[String] @implements Writer {
    void write(Buffer data) {
        if (data.isa(String))
            append(String.cast(data));
        else
            append(String(data));
    }
    void write(byteptr data) {
        append(String(data));
    }
}

## An HTTP Server.
##
## TODO: make this class proactor based.
class SCGIServer {
    
    class Client {
        ManagedBuffer inbuf = {1024};
        SCGIServer server;
        SCGIRequest request;
        HandlerArray handlers;
        Socket sock;
        InetAddress addr;
        int state;
        
        OutQueue outQueue = {};
                
        ## the index of the first byte in the buffer that has been read but 
        ## not processed.
        uint pos;
        
        oper init(Socket sock, InetAddress addr, HandlerArray handlers) :
            sock = sock, 
            addr = addr,
            handlers = handlers {
        }

        void formatTo(Formatter fmt) {
            fmt `Client: $sock, $addr `;
        }

        ## Returns a byteptr to the current input buffer read position.
        @final byteptr getInputBuf() {
            if (inbuf.cap - inbuf.size < 1024)
                # since the start size is 1024, we can assume that we will 
                # grow to accomodate a 1024 byte buffer.
                inbuf.grow(inbuf.cap * 2);
            return inbuf.buffer + pos;
        }

        @final void __badRequest() {
            cerr `Invalid request from $(this)\n`;
        }        

        @final bool readChunk() {
            amtRead := sock.read(WriteBuffer(getInputBuf(), 0, 1024));
            if (!amtRead) {
                return false;
            } else {
                parseNext(amtRead);
                return true;
            }
        }
    } // end of Client
    
    int __port;
    Socket __sock = {AF_INET, SOCK_STREAM, 0};
    HashMap[FileHandle, Client] __clients = {};
    Poller __poller = {};
    Array[FileHandle] __toRemove = {};
    HandlerArray __handlers = {};

    oper init(int port) {
        if (!__sock.bind(InetAddress(0, port))) 
            throw SystemError('bind failed', errno());
        if (!__sock.listen(5)) 
            throw SystemError('listen failed', errno());
        if (!__sock.setReuseAddr(true))
            info `WARN: reuseaddr failed: $(strerror())\n`;
        __poller.add(__sock, POLLIN);
    }

    void __accept() {
        clientAccepted := __sock.accept();
        info `  got connection from $(clientAccepted.addr) with ref count \
$(clientAccepted.sock.refCount) on $(clientAccepted.sock.fd)\n`;
        __poller.add(clientAccepted.sock, POLLIN);
        __clients[clientAccepted.sock] =
            Client(clientAccepted.sock,
                   InetAddress.cast(clientAccepted.addr),
                   __handlers);
    }
    
    void __processClientRead(FileHandle p) {
        client := __clients[p];
        if (!client.readChunk()) {
            info `deleting client $p)\n`;
            __clients.delete(p);
            # XXX should do a deferred close here
            client.sock.close();
            __toRemove.append(p);
        }
    }
    
    void __processClientWrite(FileHandle p) {
        # find the client
        client := __clients[p];
        
        # XXX this is rubbish.  Fix it
        while (client.outQueue) {
            info `writing $(client.outQueue[0].getRepr())\n`;
            client.sock.send(client.outQueue[0], 0);
            client.outQueue.delete(0);
        }
    }

    ## Adds the given handler to the chain.  Handlers are called in the order 
    ## in which they were added until one of them returns true.
    void addHandler(Functor1[bool, SCGIRequest] handler) {
        __handlers.append(handler);
    }
    
    ## Process a single event.
    ## If 'timeout' is not null, it is the timeout to wait for the next event.
    void processOnce(TimeDelta timeout) {
        
        # go through the clients, change their events
        for (clientItem :in __clients)
            if (clientItem.val.outQueue)
                __poller.setEvents(clientItem.val.sock, POLLIN | POLLOUT);
            else
                __poller.setEvents(clientItem.val.sock, POLLIN);
        
        debug `waiting for an event\n`;
        result := __poller.wait(timeout);
        debug `got events: $result\n`;
        while (evt := __poller.nx()) {
            info `  event is on $(evt.pollable)\n`;
            # if it's the server socket, do an accept
            if (evt.pollable is __sock) {
                info `  got new connection\n`;
                __accept();
            # client events
            } else {
                if (POLLIN & evt.revents) {
                    info `  got client read\n`;
                    __processClientRead(evt.pollable);
                } else if (POLLOUT & evt.revents) {
                    info `  got client writable\n`;
                    __processClientWrite(evt.pollable);
                } else if (POLLERR & evt.revents) {
                    info `  error on socket $(evt.pollable)\n`;
                } else {
                    info `  wtf???  pollable = $(evt.pollable), events = \
$(evt.events), revents = $(evt.revents)\n`;
                }
            }
        }
        
        # remove pollables that we're done with.
        if (__toRemove) {
            for (p :in __toRemove) {
                info `removing $p\n`;
                __poller.remove(p);
            }
            while (__toRemove)
                __toRemove.delete(0);
            info `removals finished\n`;
        }
    }
    
    void run() {
        while (true) {
            processOnce(null);
        }
    }
    
    int getPort() { return __port; }
}



